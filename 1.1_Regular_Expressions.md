正则表达式（**Regular Expressions**，简称 **Regex** 或 **RegExp**）是一种用于匹配字符串模式的强大工具，广泛应用于文本搜索、替换和数据处理。以下是其基本语法和使用方法：

---

### **1. 元字符（Meta-characters）**
元字符是正则表达式的核心，用于定义匹配模式。以下是常用的元字符及其含义：

| **元字符** | **描述**                                                                                     | **示例**                     | **匹配**                       |
|------------|---------------------------------------------------------------------------------------------|------------------------------|---------------------------------|
| `.`        | 匹配任意单个字符（除了换行符 `\n`，除非使用 `re.DOTALL`）。                                   | `a.b`                        | 匹配 `aab`、`acb`，但不匹配 `ab` |
| `^`        | 匹配字符串的开头。                                                                           | `^abc`                       | 匹配以 `abc` 开头的字符串       |
| `$`        | 匹配字符串的结尾。                                                                           | `xyz$`                       | 匹配以 `xyz` 结尾的字符串       |
| `*`        | 匹配前一个字符 0 次或多次。                                                                  | `ab*`                        | 匹配 `a`、`ab`、`abb` 等       |
| `+`        | 匹配前一个字符 1 次或多次。                                                                  | `ab+`                        | 匹配 `ab`、`abb`，但不匹配 `a` |
| `?`        | 匹配前一个字符 0 次或 1 次（非贪婪匹配）。                                                   | `ab?`                        | 匹配 `a` 或 `ab`               |
| `{n}`      | 匹配前一个字符恰好 n 次。                                                                    | `a{3}`                       | 匹配 `aaa`                     |
| `{n,}`     | 匹配前一个字符至少 n 次。                                                                    | `a{2,}`                      | 匹配 `aa`、`aaa`、`aaaa` 等    |
| `{n,m}`    | 匹配前一个字符至少 n 次，至多 m 次。                                                         | `a{2,4}`                     | 匹配 `aa`、`aaa` 或 `aaaa`     |
| `[]`       | 匹配括号内的任意字符。                                                                       | `[abc]`                      | 匹配 `a`、`b` 或 `c`           |
| `|`        | 表示“或”（逻辑 OR）。                                                                        | `abc|def`                    | 匹配 `abc` 或 `def`            |
| `()`       | 定义分组，捕获匹配内容。                                                                     | `(abc)+`                     | 匹配 `abc`、`abcabc` 等        |
| `\`        | 转义字符，用于匹配元字符本身或表示特殊序列（如 `\d`）。                                      | `\.`                         | 匹配 `.`                       |

---

### **2. 特殊字符类**
正则表达式提供了一些预定义的字符类，简化复杂的匹配。

| **字符类** | **描述**                                                                                     | **示例**                     | **匹配**                       |
|------------|---------------------------------------------------------------------------------------------|------------------------------|---------------------------------|
| `\d`       | 匹配任意数字（相当于 `[0-9]`）。                                                             | `\d+`                        | 匹配 `123`、`456`              |
| `\D`       | 匹配任意非数字字符（相当于 `[^0-9]`）。                                                      | `\D+`                        | 匹配 `abc`、`XYZ`              |
| `\w`       | 匹配任意单词字符（字母、数字或下划线，`[a-zA-Z0-9_]`）。                                     | `\w+`                        | 匹配 `hello_123`               |
| `\W`       | 匹配任意非单词字符（相当于 `[^a-zA-Z0-9_]`）。                                               | `\W+`                        | 匹配 `@#$%`                    |
| `\s`       | 匹配任意空白字符（空格、制表符、换行符等）。                                                 | `\s+`                        | 匹配空格或换行                 |
| `\S`       | 匹配任意非空白字符（相当于 `[^ \t\n\r\f\v]`）。                                              | `\S+`                        | 匹配 `abc123`                  |
| `.`        | 匹配任意字符（除换行符外）。                                                                 | `a.c`                        | 匹配 `abc`、`a1c`              |

---

### **3. 边界匹配**
正则表达式的边界匹配用于限定匹配的位置。

| **边界符** | **描述**                                                                                     | **示例**                     | **匹配**                       |
|------------|---------------------------------------------------------------------------------------------|------------------------------|---------------------------------|
| `\b`       | 匹配单词边界。                                                                               | `\bword\b`                   | 匹配 `word`，但不匹配 `sword`  |
| `\B`       | 匹配非单词边界。                                                                             | `\Bword\B`                   | 匹配 `swordfish` 的 `word` 部分 |
| `^`        | 匹配字符串开头。                                                                             | `^hello`                     | 匹配以 `hello` 开头的字符串    |
| `$`        | 匹配字符串结尾。                                                                             | `world$`                     | 匹配以 `world` 结尾的字符串    |

---

### **4. 贪婪与非贪婪匹配**
正则表达式默认是**贪婪模式（Greedy）**，会尽可能多地匹配字符。非贪婪模式通过在量词后加 `?` 实现。

| **模式**          | **描述**                                | **示例**         | **匹配**                       |
|--------------------|------------------------------------------|------------------|---------------------------------|
| 贪婪匹配（默认）   | 尽可能多地匹配字符                      | `a.*b`           | 匹配 `a1234b`                  |
| 非贪婪匹配         | 匹配到最短可能的字符                    | `a.*?b`          | 匹配 `a1b`（遇到第一个 `b` 就停止） |

---

### **5. 常见正则表达式示例**

#### **1. 匹配邮箱地址**
```regex
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
```
- 匹配：`example@gmail.com`

#### **2. 匹配电话号码**
```regex
\d{3}-\d{3}-\d{4}
```
- 匹配：`123-456-7890`

#### **3. 匹配 IP 地址**
```regex
(?:\d{1,3}\.){3}\d{1,3}
```
- 匹配：`192.168.1.1`

#### **4. 匹配日期（YYYY-MM-DD）**
```regex
\d{4}-\d{2}-\d{2}
```
- 匹配：`2023-01-01`

#### **5. 匹配 URL**
```regex
https?://[a-zA-Z0-9.-]+(?:\.[a-zA-Z]{2,})+
```
- 匹配：`http://example.com`

---

### **6. Python 中使用正则表达式**

在 Python 中，可以使用内置的 `re` 模块处理正则表达式。

#### **基本操作**
```python
import re

# 匹配
pattern = r'\d+'
text = "There are 123 apples"
match = re.search(pattern, text)
print(match.group())  # 输出：123

# 替换
result = re.sub(r'apples', 'bananas', text)
print(result)  # 输出：There are 123 bananas

# 查找所有匹配
matches = re.findall(r'\d+', text)
print(matches)  # 输出：['123']
```
